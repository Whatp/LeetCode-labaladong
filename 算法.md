# Leetcode刷题遇到的知识点总结

## Comparator接口

```java
Arrays.sort(intervals, new Comparator<int[]>() {
    public int compare(int[] interval1, int[] interval2) {
        return interval1[0] - interval2[0];
    }
});

```

`Comparator`是Java中一个函数式接口，用于比较两个对象，定义对象排序的方式。让开发者能够自定义排序规则，默认情况下，`Arrays.sort()`会按照元素的自然顺序进行排序，但是在一些情况下，我们需要自定义排序规则，比如对自定义对象或者多维数组的特定部分进行排序。等价于`Lambda`表达式的写法。

```java
Arrays.sort(intervals, (interval1, interval2) -> interval1[0] - interval2[0]);

```

`Lambda`表达式可以减少代码量，但是和使用`Comparator`的内部类实现具有相同的功能。

## 链表遇到的问题：循环里面判断对错的逻辑

### [234. 回文链表 - 力扣（LeetCode）](https://leetcode.cn/problems/palindrome-linked-list/?envType=study-plan-v2&envId=top-100-liked)

给你一个单链表，判断是否是回文链表，个人使用遍历一遍，把元素加入到Array List中，再判断，判断的时候逻辑出了问题，不应该在循环里面判断，应该先判错，如果循环结束之后还是没有错，在循环外面返回正确。

![image-20241028202535621](C:\Users\李公正\AppData\Roaming\Typora\typora-user-images\image-20241028202535621.png)

### [141. 环形链表 - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle/description/?envType=study-plan-v2&envId=top-100-liked)

环形链表的问题，用哈希表来做的话，在循环里面判断是否将节点加入进去了，如果一直没有加进去就返回true，最后如果加进去了就返回false。这个是逻辑上的问题，特别是循环里面判断要根据具体情况来，像这个环形链表，如果在里面判断节点加进去返回false的画，`return false;`的位置放在 `if (set.add(head))` 的条件中，这意味着只要成功添加了一个节点就会返回 `false`，这会导致即使链表有环，代码也会错误地返回 `false`。**`set.add(head)` 返回 `true`**：表示该节点不在集合中，成功添加。我们继续遍历下一个节点。

set不允许重复，如果可以添加进去就会返回true，不能添加进去就回返回false。if里面的条件为真时才会执行该语句

**`set.add(head)` 返回 `false`**：表示该节点已在集合中，说明链表存在环，应立即返回 `true` 表示链表是环形的。

# Java集合（List Map Set Queue Deque Stack)知识点

## List

> `List`是按索引顺序访问的长度可变的有序表，优先使用`ArrayList`而不是`LinkedList`；
>
> 可以直接使用`for each`遍历`List`；
>
> `List`可以和`Array`相互转换。



## Map

```ascii
       ┌───┐   				
       │Map│																
       └───┘
         ▲
    ┌────┴─────┐
    │          │
┌───────┐ ┌─────────┐
│HashMap│ │SortedMap│
└───────┘ └─────────┘
               ▲
               │
          ┌─────────┐
          │ TreeMap │
          └─────────┘
```

> `SortedMap`在遍历时严格按照Key的顺序遍历，最常用的实现类是`TreeMap`；
>
> 作为`SortedMap`的Key必须实现`Comparable`接口，或者传入`Comparator`；
>
> 要严格按照`compare()`规范实现比较逻辑，否则，`TreeMap`将不能正常工作



>  要正确使用`HashMap`，作为`key`的类必须正确覆写`equals()`和`hashCode()`方法；
>
> 一个类如果覆写了`equals()`，就必须覆写`hashCode()`，并且覆写规则是：
>
> - 如果`equals()`返回`true`，则`hashCode()`返回值必须相等；
> - 如果`equals()`返回`false`，则`hashCode()`返回值尽量不要相等。
>
> 实现`hashCode()`方法可以通过`Objects.hashCode()`辅助方法实现。



## Set

```ascii
	   ┌───┐
       │Set│
       └───┘
         ▲
    ┌────┴─────┐
    │          │
┌───────┐ ┌─────────┐
│HashSet│ │SortedSet│
└───────┘ └─────────┘
               ▲
               │
          ┌─────────┐
          │ TreeSet │
          └─────────┘
```

> `Set`用于存储不重复的元素集合：
>
> - 放入`HashSet`的元素与作为`HashMap`的key要求相同；
> - 放入`TreeSet`的元素与作为`TreeMap`的Key要求相同；
>
> 利用`Set`可以去除重复元素；
>
> 遍历`SortedSet`按照元素的排序顺序遍历，也可以自定义排序算法。



## Queue

> 队列`Queue`实现了一个先进先出（FIFO）的数据结构：
>
> - 通过`add()`/`offer()`方法将元素添加到队尾；
> - 通过`remove()`/`poll()`从队首获取元素并删除；
> - 通过`element()`/`peek()`从队首获取元素但不删除。
>
> 要避免把`null`添加到队列。

LinkedList即实现了List接口，又实现了Queue接口，但是，在使用的时候，如果我们把它当作List，就获取List的引用，如果我们把它当作Queue，就获取Queue的引用：

```java
// 这是一个List:
List<String> list = new LinkedList<>();
// 这是一个Queue:
Queue<String> queue = new LinkedList<>();
```



## Deque

> `Deque`实现了一个双端队列（Double Ended Queue），它可以：
>
> - 将元素添加到队尾或队首：`addLast()`/`offerLast()`/`addFirst()`/`offerFirst()`；
> - 从队首／队尾获取元素并删除：`removeFirst()`/`pollFirst()`/`removeLast()`/`pollLast()`；
> - 从队首／队尾获取元素但不删除：`getFirst()`/`peekFirst()`/`getLast()`/`peekLast()`；
> - 总是调用`xxxFirst()`/`xxxLast()`以便与`Queue`的方法区分开；
> - 避免把`null`添加到队列。

```java
// 不推荐的写法:
LinkedList<String> d1 = new LinkedList<>();
d1.offerLast("z");
// 推荐的写法：
Deque<String> d2 = new LinkedList<>();
d2.offerLast("z");
```



## Stack

> 栈（Stack）是一种后进先出（LIFO）的数据结构，操作栈的元素的方法有：
>
> - 把元素压栈：`push(E)`；
> - 把栈顶的元素“弹出”：`pop(E)`；
> - 取栈顶元素但不弹出：`peek(E)`。
>
> 在Java中，我们用`Deque`可以实现`Stack`的功能，注意只调用`push()`/`pop()`/`peek()`方法，避免调用`Deque`的其他方法。
>
> 最后，不要使用遗留类`Stack`。



# Git

### git 常用操作--本地仓库的操作

git init    --

git add .

git commit -m "  xxxxxx "    提交到本地仓库

git status



### git常用操作--远程仓库的操作

git branch -M main

git remote add origin git@github.com:Whatp/xxx.git

git remote rm xxx

git push -u roigin main

git remote -v    可查看连接的远程仓库的版本

git remote   查看当前配置有哪些仓库

git branch  -r   查看远程仓库的分支

git branch -a  查看所有仓库分支

git branch -d xxx







# 异或运算

### 异或运算

#### 1.把一个int类型的数，提取出最右侧的1出来

N&((~N)+1)    ,N交N取反加1

#### 2.一个数组中有一种数出现了奇数次，其他数出现了偶数次，怎么找出奇数次

Exclusive OR  缩写成*``xor ``*异或

```java
int xro = 0;
xor = xor^a;
xor = xor^b;
//与所有的数异或一遍
```

#### 3.一个数组中两种数出现了奇数次，其他数都出现了偶数次，怎么找到并打印这两种数

xor=a^b！=0  ,关键是怎么将a、b分出来，a和b是不相等的。有一位是不一样的，假设是第八位不同，整个数组可以分成两组，第一类是第八位是1的数，第二类是第八位是0的数，分组异或，a  b会被分到两组里。

xor'  与第八位是1的数进行异或，得到的就是a或者b，找哪一位可以参照 题目1. 



# 快慢指针

### 快慢指针

```
快指针走两步，慢指针走一步，当快指针走到终点的时候，慢指针应当在中点，但是位置需要确定
```

####  1.输入链表头节点，奇数长度返回中点，偶数长度返回上中点

![中点或上中点](C:\Users\李公正\AppData\Roaming\Typora\typora-user-images\image-20231023095811356.png)

####  2.输入链表头节点，奇数长度返回中点，偶数长度返回下中点

![image-20231023100112830](C:\Users\李公正\AppData\Roaming\Typora\typora-user-images\image-20231023100112830.png)

#### 3.奇数长度返回中点前一个，偶数长度返回上中点前一个

![image-20231023100259058](C:\Users\李公正\AppData\Roaming\Typora\typora-user-images\image-20231023100259058.png)

#### 4.奇数长度返回中点前一个，偶数长度返回下中点前一个

![image-20231023100234587](C:\Users\李公正\AppData\Roaming\Typora\typora-user-images\image-20231023100234587.png)

将链表节点数据放入数组中，直接在数组中进行操作

#### 快慢指针，删除倒数第n个节点

思路:先创建一个新节点令其指向头结点，慢指针指向开头，快指针先走n步。让慢指针少走一步，这样方便删除；而且若只有一个节点时，删除倒数第一个节点后应该为空，新建一个节点使其指向p节点指向的节点，并返回。

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        // 两个指针，相差n步,慢指针正好是要删除的节点,要记录慢指针之前的一个节点，方便删除
        ListNode p = new ListNode(0,head);
        ListNode fast = head;
        ListNode slow = p;
        for(int i = 1;i<n;i++){
            fast = fast.next;
        }
        while(fast.next!=null){
            fast = fast.next;
            slow = slow.next;
        }
        slow.next = slow.next.next;
        ListNode ans = p.next;
        return ans;
    }
}
```





# 链表

## 链表

### 将链表分为左右两部分，左边的数据小于指定数据，右边的数据大于指定数据

分析：创建七个指针分别为：sH  sT :小于区域的头和尾  eT eS mH mT  以及一个工作指针p来指向头结点，指示位置。在分完之后需要连接头尾指针，此时需要进行判断，因为不一定三个区域不一定都存在。  

![image-20231026135803819](C:\Users\李公正\AppData\Roaming\Typora\typora-user-images\image-20231026135803819.png)



### 当一个链表有环时，怎么找到第一个入环的节点

1.***hashset*:**将每个节点进行比较，如果尚未存在则放入，如果第一次出现重复则该节点为第一个入环的节点。

2.***使用快慢指针***。当快慢指针相同时，说明有环，再令一个指针回到开头，两个一起走，每次一步，相遇时必为第一个入环的节点。

### 两个链表均无环，查找两个链表中，相交的第一个节点，如果不相交，则返回空

1.***哈希表***.将其中一个链表放入哈希表中，另一个表中的节点挨个查找。

2.首先两个链表都走到最后，同时计算出差值。如果最后一个节点不相同，则说明不相交。长的链表先走差值步，再同时前进，走到相同时，第一个节点即为所求。

### 两个链表均有环，怎么查找相交的第一个节点

***分析：分成三种情况，都有环时：1.两个链表并不相交，则为空。2.两个链表的入环节点是一个。3.两个链表的入环节点不是一个。*** loop1:时链表1的入环节点

2.两个链表分别找到入环的第一个节点，如果**入环的节点相同**则说明两个链表属于第二种情况。将其转换成两个链表无环时的操作，查找相交的第一个节点。

如果入**环节点不相等**时，loop1转一圈如果没有遇到loop2，说明是情况1，否则是情况3.



 

# 二叉树

## 二叉树

### 二叉树的前序、中序、后序遍历  ---迭代、递归、Morris遍历

思路：弹出节点,打印

#### 先序遍历  ：中   左   右

##### method1-迭代(左程云)

```java
//中  左  右
public static void preorder(Node root){
    System.out.println("前序遍历；");
    if(root!=null){
        Stack<Node> stk = new Stack<Node>();
        stk.push(root);
        while(!stk.imEmpty()){
            root = stk.pop();
            System.out.println(root.value +" ");
            //先右再左
            if(root.right!=null){
				stk.push(root.right);	
            }
            if(root.left!=null){
                stk.push(root.left);
            }
        }
    }
    System.out.println();
}
```

##### method2-迭代(leetcode)

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        if (root == null) {
            return res;
        }

        Deque<TreeNode> stack = new LinkedList<TreeNode>();
        TreeNode node = root;
        while (!stack.isEmpty() || node != null) {
            while (node != null) {
                res.add(node.val);
                stack.push(node);
                node = node.left;
            }
            node = stack.pop();
            node = node.right;
        }
        return res;
    }
}

```

##### method3-递归(leetcode)

```java
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        preorder(root, res);
        return res;
    }

    public void preorder(TreeNode root, List<Integer> res) {
        if (root == null) {
            return;
        }
        res.add(root.val);
        preorder(root.left, res);
        preorder(root.right, res);
    }
}
```

#### 后序遍历  ：左 右 中

头 右 左 的访问顺序，在栈中则是 头 左 右 ，因为栈的入栈顺序和出栈顺序不同。这样访问结束后，从后往前则是后序遍历的顺序，需要定义一格栈，专门用来放弹出的数。

##### method1-迭代(左程云)

```java
public static void postorder(Node head){
	System.out.println("postorder");
	if(head!=null){
		Stack<Node> s1 = new Stack<Node>();
		Stack<Node> s2 = new Stack<Node>();
		s1.push(head);
		while(!s1.isEmpty()){
			head = s1.pop();
			//不打印，放到栈里面
			s2.push(head);
            //先左再右
			if(head.left!=null){
				s1.push(head.left);
			}
			if(head.right!=null){
				s1.push(head.right);
			}
		}
		while(!s2.isEmpty()){
			System.out.println(s2.pop().val + " ");
		}
	}
	sout();
}
```

##### method2-迭代(leetcode)

```java
class Solution{
    public List<Integer> method1(TreeNode root) {
        List<Integer> ans=new LinkedList<>();
        Stack<TreeNode> stack=new Stack<>();
        TreeNode prev=null;
        //主要思想：
        //由于在某颗子树访问完成以后，接着就要回溯到其父节点去
        //因此可以用prev来记录访问历史，在回溯到父节点时，可以由此来判断，上一个访问的节点是否为右子树
        while(root!=null||!stack.isEmpty()){
            while(root!=null){
                stack.push(root);
                root=root.left;
            }
            //从栈中弹出的元素，左子树一定是访问完了的
            root=stack.pop();
            //现在需要确定的是是否有右子树，或者右子树是否访问过
            //如果没有右子树，或者右子树访问完了，也就是上一个访问的节点是右子节点时
            //说明可以访问当前节点
            if(root.right==null||prev==root.right){
                ans.add(root.val);
                //更新历史访问记录，这样回溯的时候父节点可以由此判断右子树是否访问完成
                prev=root;
                root=null;
            }else{
            //如果右子树没有被访问，那么将当前节点压栈，访问右子树
                stack.push(root);
                root=root.right;
            }
        }
        return ans;
    }
}
```

#### 中序遍历

##### method1-迭代(leetcode)

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        Deque<TreeNode> stk = new LinkedList<TreeNode>();
        while (root != null || !stk.isEmpty()) {
            while (root != null) {
                stk.push(root);
                root = root.left;
            }
            root = stk.pop();
            res.add(root.val);
            root = root.right;
        }
        return res;
    }
}

```

##### method2-递归(leetcode)

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        inorder(root, res);
        return res;
    }

    public void inorder(TreeNode root, List<Integer> res) {
        if (root == null) {
            return;
        }
        inorder(root.left, res);
        res.add(root.val);
        inorder(root.right, res);
    }
}
```

##### method3-Morris(leetcode)

Morris 遍历算法是另一种遍历二叉树的方法，它能将非递归的中序遍历空间复杂度降为 O(1)O(1)O(1)。

Morris 遍历算法整体步骤如下（假设当前遍历到的节点为 xxx）：

如果 xxx 无左孩子，先将 xxx 的值加入答案数组，再访问 xxx 的右孩子，即 x=x.rightx = x.\textit{right}x=x.right。
如果 xxx 有左孩子，则找到 xxx 左子树上最右的节点（即左子树中序遍历的最后一个节点，xxx 在中序遍历中的前驱节点），我们记为 predecessor\textit{predecessor}predecessor。根据 predecessor\textit{predecessor}predecessor 的右孩子是否为空，进行如下操作。
如果 predecessor\textit{predecessor}predecessor 的右孩子为空，则将其右孩子指向 xxx，然后访问 xxx 的左孩子，即 x=x.leftx = x.\textit{left}x=x.left。
如果 predecessor\textit{predecessor}predecessor 的右孩子不为空，则此时其右孩子指向 xxx，说明我们已经遍历完 xxx 的左子树，我们将 predecessor\textit{predecessor}predecessor 的右孩子置空，将 xxx 的值加入答案数组，然后访问 xxx 的右孩子，即 x=x.rightx = x.\textit{right}x=x.right。
重复上述操作，直至访问完整棵树。

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        TreeNode predecessor = null;

        while (root != null) {
            if (root.left != null) {
                // predecessor 节点就是当前 root 节点向左走一步，然后一直向右走至无法走为止
                predecessor = root.left;
                while (predecessor.right != null && predecessor.right != root) {
                    predecessor = predecessor.right;
                }
                
                // 让 predecessor 的右指针指向 root，继续遍历左子树
                if (predecessor.right == null) {
                    predecessor.right = root;
                    root = root.left;
                }
                // 说明左子树已经访问完了，我们需要断开链接
                else {
                    res.add(root.val);
                    predecessor.right = null;
                    root = root.right;
                }
            }
            // 如果没有左孩子，则直接访问右孩子
            else {
                res.add(root.val);
                root = root.right;
            }
        }
        return res;
    }
}

作者：力扣官方题解
链接：https://leetcode.cn/problems/binary-tree-inorder-traversal/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

<a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">力扣官方题解</a>


## 实现二叉树的层序遍历

实现二叉树的层序遍历，可以设置`flag`，来发现某一层是否结束(看题目)。将头结点加进去，出栈并将该节点的子节点入栈

### <a href="[102. 二叉树的层序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-level-order-traversal/)">二叉树的层序遍历(leetcode)</a>

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        // 本题中返回的是双层的列表，记录了层数及数据,思路是向双层列表中加入列表
        // 基于以上思路，所以需要创建一个双层的列表，一个单层的列表，一个双端队列
        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        List<List<Integer>> res = new ArrayList<>();
        if(root!=null) queue.add(root);
        while(!queue.isEmpty()){
            List<Integer> tep = new ArrayList<>();
            for(int i = queue.size();i>0;i--){  //这个for循环是解决本问题的关键之处
                TreeNode node = queue.poll();  //此函数的作用是头结点出队并返回其值
                tep.add(node.val);
                if(node.left!=null) queue.add(node.left);
                if(node.right!=null) queue.add(node.right);
            }
            res.add(tep);
        }
        return res;

    }
}
```

```java
class Solution {
    List<List<Integer>> res = new ArrayList<List<Integer>>();

    public void helper(TreeNode node, int level){
        //新开一层
        if(res.size()==level) res.add(new ArrayList<Integer>());
        res.get(level).add(node.val);

        if(node.left!=null) helper(node.left,level+1);
        if(node.right!=null) helper(node.right,level+1);
    }

    
    public List<List<Integer>> levelOrder(TreeNode root) {
        
        if(root==null) return res;
        helper(root,0);
        return res;
    }
}
```



# 基本数据类型、引用数据类型的转化
## 基本数据类型和引用数据类型
>  字符串类型String属于引用数据类型，是一个类。在引用数据类型中，
>  通常只存在String类型和基本数据类型间的转换，并且，不同基本数据类型
>  和String类型数据的转换原理相同，方法相似。
>  char 与int的不转换
>  ![img.png](img.png)

```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
}

```

“第一，String 类是 [finalopen in new window](https://javabetter.cn/oo/final.html) 的，意味着它不能被子类[继承open in new window](https://javabetter.cn/oo/encapsulation-inheritance-polymorphism.html)。这些知识我们讲面向对象编程的时候都会讲到，三妹你不用担心。”

“第二，String 类实现了 [Serializable 接口open in new window](https://javabetter.cn/io/Serializbale.html)，意味着它可以[序列化open in new window](https://javabetter.cn/io/serialize.html)（后面同样会讲，戳链接可跳转）。”

“第三，String 类实现了 [Comparable 接口open in new window](https://javabetter.cn/basic-extra-meal/comparable-omparator.html)，意味着最好不要用‘==’来[比较两个字符串是否相等open in new window](https://javabetter.cn/string/equals.html)，而应该用 `compareTo()` 方法去比较。”

因为 == 是用来比较两个对象的地址，这个在讲[字符串比较open in new window](https://javabetter.cn/string/equals.html)的时候会详细讲。如果只是说比较字符串内容的话，可以使用 String 类的 equals 方法，源码和注释如下所示：

```java
public boolean equals(Object anObject) {
    // 检查是否是同一个对象的引用，如果是，直接返回 true
    if (this == anObject) {
        return true;
    }
    // 检查 anObject 是否是 String 类的实例
    if (anObject instanceof String) {
        String anotherString = (String) anObject; // 将 anObject 强制转换为 String 类型
        int n = value.length; // 获取当前字符串的长度
        // 检查两个字符串长度是否相等
        if (n == anotherString.value.length) {
            char v1[] = value; // 当前字符串的字符数组
            char v2[] = anotherString.value; // 另一个字符串的字符数组
            int i = 0; // 用于遍历字符数组的索引
            // 遍历比较两个字符串的每个字符
            while (n-- != 0) {
                // 如果在任何位置字符不同，则返回 false
                if (v1[i] != v2[i])
                    return false;
                i++;
            }
            // 所有字符都相同，返回 true
            return true;
        }
    }
    // 如果 anObject 不是 String 类型或长度不等，则返回 false
    return false;
}

```

## Java中equals（）与 ==  之间的区别

` == ` 操作符用于比较两个对象的地址是否相等。

`.equals()` 方法用于比较两个对象的内容是否相等。

> Java所有的类都默认继承了Object这个类，该类有一个 `.equals()` 方法:

```java
public boolean equals(Object obj) {
    return (this == obj);
}
```

你看，Object 类的 `.equals()` 方法默认采用的是“==”操作符进行比较。假如子类没有重写该方法的话，那么“==”操作符和 `.equals()` 方法的功效就完全一样——比较两个对象的内存地址是否相等。

但实际情况中，有不少类重写了 `.equals()` 方法，因为比较内存地址的要求比较严格，不太符合现实中所有的场景需求。拿 String 类来说，我们在比较字符串的时候，的确只想判断它们俩的内容是相等的就可以了，并不想比较它们俩是不是同一个对象。

况且，字符串有[字符串常量池open in new window](https://javabetter.cn/string/constant-pool.html)的概念，本身就推荐使用 `String s = "字符串"` 这种形式来创建字符串对象，而不是通过 new 关键字的方式，因为可以把字符串缓存在字符串常量池中，方便下次使用，不用遇到 new 就在堆上开辟一块新的空间。

## 1.各种数据类型之间的转换

### 1.1基本数据类型转成String类型

string类实现了Comparable接口，意味着最好不要用" == " 来比较两个字符串是否相等，而应该用compareTo()方法去比较.

#### 1.1.1  方式一：使用String类的静态方法valueOf()        `推荐`
!注意：valueOf()方法的参数类型，与基本数据类型一致
```java
public class DataTypeConversion {
    public static void main(String[] args) {
        int i = 100;
        String s = String.valueOf(i);
        System.out.println(s);
    }
}
```

#### 1.1.2 方式二：使用基本数据类型的值+空字符串  
!注意：空字符串""的本质是一个空格
```java
public class DataTypeConversion {
    public static void main(String[] args) {
        int i = 100;
        String s = i + "";
        System.out.println(s);
    }
}
```

#### 1.1.3 方式三：使用包装类的静态方法toString()  
!注意：toString()方法的参数类型，与基本数据类型一致
```java
public class DataTypeConversion {
    public static void main(String[] args) {
        int i = 100;
        String s = Integer.toString(i);
        System.out.println();
    }
}
```
###  1.2 String类型   转成基本数据类型 

#### 1.2.1 方式一：使用包装类的静态方法parseXXX("字符串")    `推荐`
!注意：parseXXX()方法的参数类型，与基本数据类型一致
如果使用valueOf()的方法，会造成拆箱冗余，其内部调用了parseInt()方法，推荐使用parseInt()
```java
public class DataTypeConversion {
    public static void main(String[] args) {
        String s = "100";
        int i = Integer.parseInt(s);
        System.out.println(i);
    }
}
```
#### 1.2.2 方式二：使用包装类的静态方法valueOf("字符串")      
!注意：valueOf()方法的参数类型，与基本数据类型一致
```java
public class DataTypeConversion {
    public static void main(String[] args) {
        String s = "100";
        int i = Integer.valueOf(s);
        System.out.println(i);
    }
}
```
#### 1.2.3 方式三：使用Character.digit(char ch, int radix)
```java
public class DataTypeConversion {
    public static void main(String[] args) {
        String s = "100";
        int i = Character.digit(s.charAt(0), 10);
        System.out.println(i);
    }
}
```

## 2.int和Integer的区别

1. int是基本数据类型，Integer是引用数据类型
2. int的默认值是0，Integer的默认值是null
3. int变量不能直接赋值为null，Integer变量可以赋值为null

## 3.自动装箱与自动拆箱

1. 自动装箱：基本数据类型自动转换为对应的包装类型
2. 自动拆箱：包装类型自动转换为对应的基本数据类型

## 4.int数据和char数据的转换

### 4.1 int数据转char数据
int转换为字符数组，先将int转为String，再将String转为char数组
```java
public class DataTypeConversion {
    public static void main(String[] args) {
        int i = 97;
        String str = String.valueOf(i);
        char [] c = str.toCharArray();
    }
}
```
### 4.2 char数据转int数据
先借助String的valueOf()方法将char转为String，再借助Integer的parseInt()方法将String转为int
```java
public class DataTypeConversion {
    public static void main(String[] args) {
        char c = 'a';
        String str = String.valueOf(c);
        int n = Integer.parseInt(str);
        
    }
}
```

### 5.数字和字符转换

* 字符转数字 用减法  'x' - '0'

* 数字转字符 用加法 1 + '0'

  

  * 字符与字符进行加减运算     此时会先将字符转换为ASCII码，将二者ASCII码值相加。

  ```java
  char i = '3' + '0';
  int j = '3' + '0';
  i的值为c，j的值为99，因为字符c的ASCII码为99
  ```

  * 字符与数字进行加减运算    会将字符转换为ASCII码，然后和数字相加。

  ```java
  char i = 3 + '0';
  int j = 3 + '0';
  i的值为3，因为字符0的ASCII码为48，加3后为51，而51正好是字符3的ascii码；那么很显然j的值就为51
  ```

  

# hashset hashtable hashmap

## hashset hashtable hashmap 的区别

1. hashset 是无序的，hashtable 是排序的
2. hashset 是线程不安全的，hashtable 是线程安全的
3. hashset 允许null值，hashtable 不允许null值
4. hashset 是集合，hashtable 是map

## hashset  和 hashmap 的区别

1. hashset 是无序的，hashmap 是无序的
2. hashset 是线程不安全的，hashmap 是线程安全的
3. hashset 允许null值，hashmap 不允许null值
4. hashset 是集合，hashmap

# 排序算法

## 冒泡排序

```java
 for (int i = 0; i < array.length - 1; i++) {
//            每趟都会有一个最大的数排好序，所以可以进行优化
            for (int j = 0; j < array.length - i - 1; j++) {
                if (array[j] > array[j + 1]) {
                    int temp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = temp;
                }
            }
        }
```

  ## 选择排序

```java
for(int i = 0; i < a.length-1; i++) {
            int k =i;  // 下标
            //                先让temp赋值为第一个数，然后进行比较
            int temp = a[i];
            for(int j = i+1; j < a.length; j++){
                if(a[j]<temp){
                    temp = a[j];
                    k = j;
                }
            }
            a[k] = a[i];
            a[i] = temp;
        }

// 也可以用when
int begin = 0;
int end = a.length -1;
while(begin<end){

    int min = a[begin];
    int t = begin;
    for(){}
}
```

## 插入排序

```java
for (int i = 1; i < a.length; i++) {
            int k = a[i];  // 哨兵，从数组的第二个开始，每一次循环向后移动一位
            int j = i - 1;
//            while (j >= 0 && a[j] > k) {
//                a[j + 1] = a[j];
//                j--;
//            }
//            a[j + 1] = k;
            for(;j>=0&&a[j]>k;j--)
            {
                a[j+1]=a[j];
            }
            a[j+1]=k;
        }
```



# 数论

## 唯一分解定理

任何一个大于1的自然数N，如果N不为质数，那么N可以唯一分解成有限个质数的乘积。

## 快速幂

` 引理：积的取余等于取余的积的取余` 

` 积的余 等于 余的积 `

* 对于a和b较小时直接用int或者long是没有问题的，但是达到一定程度时，就不是暴力存就能够解决问题的，可以取模

```java
// n为底数，m表示次幂
// base = n 表示的是 n^(2^0)
// m的二进制的最后一位是否为1
// 将m的二进制的最后一位移除
// 对奇偶性进行判定
private static int pow(int n, int m) 
    int res = 1;                     
    int base = n;                    
    while(m != 0) {                  
        if ((m&1) == 1) {            
            res = res * base;        
        }                            
        base = base * base;          
        m = m >> 1;                  
    }                                
    return res;                      
}                       


public static long qmi(long n, long m){
        long res = 1;
        while(m!=0) {
            if((m&1)==1) res = res * n ;
            n = n*n ;
            m>>=1;
        }
        return res;
    }

public static long qmi(long n, long m){
        long res = 1;
        while(m!=0) {
            if((m&1)==1) res = res * n %mod;
            n = n*n %mod;
            m>>=1;
        }
        return res;
    }
```

## 分解质因式



## 互质数的个数

```java
import java.util.Scanner;

public class Main{
  static int mod = 998244353;
  //快速幂
  static long qmi(long a,long b){
    long res = 1;
    while(b>0){
      if((b&1)>0){
        res = (res*a)%mod;
      }
      a = (a*a)%mod;
      b>>=1;
    }
    return res;
  }
  public static void main(String[] args) {
    Scanner scan = new Scanner(System.in);
    int a=scan.nextInt();
    long b=scan.nextLong();
    long res = a; 
    long temp = a;
    for(int i=2;i<=temp/i;i++){
      if(temp%i==0){
        res = res/i*(i-1);
        while(temp%i==0) temp/=i;
      }
    }
    if(temp>1) res = res/temp*(temp-1);
    long t = qmi(a,b-1);
    res = (res*t)%mod;
    System.out.println(res);
  }
}
```



## 欧拉函数

```java
long res = a, x = b;
if(a == 1) return 0;
for(int i = 2; i*i <= x; i++){
    if(x % i == 0){
        while(x%i == ) x/=i;
        res = res / i*(i-1); //欧拉公式
    }
}
if(x > 1) res = res / x*(x-1)  //x也是一个质因子
    
sout(res * qmi(a,b-1));  //res* a^(b-1)   ，快速幂算法
```



# interview 150

#### 数组/字符申    24

- [x] 1.合并两个有序数组    Easy
- [x] 2.移除元素    Easy 
- [x] 3.删除有序数组中的重复项    Easy 
- [x] 4.删除有序数组中的重复项 Ⅱ    Medium
- [x] 5.多数元素    Easy
- [x] 6.轮转数组    Medium
- [x] 7.买卖股票的最佳时机
- [x] 8.买卖股票的最佳时机 Ⅱ
- [x] 9.跳跃游戏
- [x] 10.跳跃游戏 Ⅱ
- [x] 11. H 指数
- [x] 12. O(1) 时间插入、删除和获取随机元素
- [x] 13.除自身以外数组的乘积
- [x] 14.加油站
- [x] 15.分发糖果
- [ ] 16.接雨水
- [x] 17.罗马数字转整数
- [x] 18.整数转罗马数字
- [x] 19.最后一个单词的长度
- [x] 20.最长公共前缀
- [x] 21.反转字符串中的单词
- [x] 22. Z 字形变换
- [x] 23.找出字符串中第一个匹配项的下标
- [ ] 24.文本左右对齐

#### 双指针         5

- [x] 1.验证回文串
- [x] 2.判断子序列
- [x] 3.两数之和 Ⅱ - 输入有序数组
- [x] 4.盛最多水的容器
- [x] 5.三数之和

#### 滑动密口       4

- [x] 长度最小的子数组
- [x] 无重复字符的最长子串
- [x] 串联所有单词的子串
- [x] 最小覆盖子串

#### 矩阵           5

- [x] 有效的数独
- [x] 螺旋矩阵
- [x] 旋转图像
- [x] 矩阵置零
- [x] 生命游戏

#### 哈希表         9

- [x] 赎金信
- [x] 同构字符串
- [x] 单词规律
- [x] 有效的字母异位词
- [x] 字母异位词分组
- [x] 两数之和
- [x] 快乐数
- [x] 存在重复元素 Ⅱ
- [x] 最长连续序列

#### 区间           4

- [x] 汇总区间
- [x] 合并区间
- [x] 插入区间
- [ ] 用最少数量的箭引爆气球

#### 栈             5

- [x] 有效的括号
- [x] 简化路径
- [x] 最小栈
- [x] 逆波兰表达式求值
- [ ] 基本计算器

#### 链表           11

- [x] 环形链表
- [x] 两数相加
- [x] 合并两个有序链表
- [x] 随机链表的复制
- [x] 反转链表 Ⅱ
- [x] K个一组翻转链表
- [x] 删除链表的倒数第 N 个结点
- [x] 删除排序链表中的重复元素 Ⅱ
- [x] 旋转链表
- [x] 分隔链表
- [x] LRU 缓存

#### 二叉树         14

- [x] 二叉树的最大深度  
- [x] 相同的树
- [x] 翻转二叉树
- [x] 对称二叉树
- [ ] 从前序与中序遍历序列构造二叉树
- [ ] 从中序与后序遍历序列构造二叉树
- [ ] 填充每个节点的下一个右侧节点指针 Ⅱ
- [x] 二叉树展开为链表
- [x] 路径总和
- [x] 求根节点到叶节点数字之和
- [x] 二叉树中的最大路径和
- [x] 二叉搜索树迭代器
- [x] 完全二叉树的节点个数
- [x] 二叉树的最近公共祖先

#### 二叉树层次遍历     4

- [x] 二叉树的右视图
- [x] 二叉树的层平均值
- [x] 二叉树的层序遍历
- [x] 二叉树的锯齿形层序遍历

#### 二叉搜素树         3

- [x] 二叉搜索树的最小绝对差
- [x] 二叉搜索树中第K小的元素
- [x] 验证二叉搜索树
x
#### 图             6

- [x] 岛屿数量
- [x] 被围绕的区域
- [x] 克隆图
- [ ] 除法求值x
- [x] 课程表
- [x] 课程表 Ⅱ

#### 图的广度优先搜素      3

- [ ] 蛇梯棋
- [x] 最小基因变化
- [x] 单词接龙

#### 字典树         3
  
- [x] 实现 Trie (前缀树)
- [x] 添加与搜索单词-数据结构设计
- [x] 单词搜索 Ⅱ

#### 回湖           7

- [x] 电话号码的字母组合
- [x] 组合
- [x] 全排列
- [x] 组合总和
- [x] N 皇后Ⅱ
- [x] 括号生成
- [x] 单词搜索

#### 分治       4

- [x] 将有序数组转换为二叉搜索树
- [x] 排序链表
- [ ] 建立四叉树
- [x] 合并K个升序链表

#### Kadane 真法        2

- [x] 最大子数组和
- [x] 环形子数组的最大和

#### 二分查找       7

- [x] 搜索插入位置
- [x] 搜索二维矩阵
- [x] 寻找峰值
- [x] 搜索旋转排序数组
- [x] 在排序数组中查找元素的第一个和最后一个位置
- [x] 寻找旋转排序数组中的最小值
- [x] 寻找两个正序数组的中位数

#### 堆     4

- [x] 数组中的第K个最大元素
- [x] IPO
- [x] 查找和最小的 K 对数字
- [x] 数据流的中位数

#### 位运算     6

- [ ] 二进制求和
- [ ] 颠倒二进制位
- [ ] 位1的个数
- [ ] 只出现一次的数字
- [ ] 只出现一次的数字 Ⅱ
- [ ] 数字范围按位与

#### 数学       6

- [ ] 回文数
- [ ] 加一
- [ ] 阶乘后的零
- [ ] x的平方根
- [ ] Pow(x, m)
- [ ] 直线上最多的点数

#### 一维动态规划       5

- [ ] 爬楼梯
- [ ] 打家劫舍
- [ ] 单词拆分
- [ ] 零钱兑换
- [ ] 最长递增子序列

#### 多维动态规划       9

- [ ] 三角形最小路径和
- [ ] 最小路径和
- [ ] 不同路径 Ⅱ
- [ ] 最长回文子串
- [ ] 交错字符串
- [ ] 编辑距离
- [ ] 买卖股票的最佳时机 Ⅲ
- [ ] 买卖股票的最佳时机 Ⅳ
- [ ] 最大正方形
